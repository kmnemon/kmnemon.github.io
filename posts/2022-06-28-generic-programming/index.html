<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>泛型编程浅入浅出(C++, Java, Go) | 科的随思录</title>
<meta name=keywords content><meta name=description content="今年3月随着Go 1.18版发布，引入了一个重大的语言特性：泛型编程。这个特性在发布前引起了一定的争议。崇尚少即是多的一边认为这个特性不是很必要，应该谨慎引入。另一边则认为这是语言必不可少的特性。最后Go的泛型还是如期而至
泛型编程在其他编程语言也遇到了不同的问题，比如在Java 1.0时是没有引入泛型编程支持，到了Java 1.5的时候引入了泛型，但由于引入时间过晚，有大量的标准库和第三方库无法支持，Java选择了妥协采用间接的类型擦除方式来实现泛型编程，导致泛型的使用复杂度增加，同时场景受限。而C++比较明智，一开始就支持泛型，所以在C++ STL标准库里面大量的算法都是采用泛型实现，整个语言体系中泛型占据了核心位置
学习一个语言的特性可以参考其他语言同样的特性，这样就可以了解这个语言特性实现是否设计合理，是否优雅，存在哪些局限性
语言版本：
C++11
Java 11
Go 1.18
1. 泛型函数
泛型函数用来支持当一个算法用在多种数据类型上，为了避免重复的定义函数，而用泛型函数来支持
两个数据进行取小操作
//C++
template <class T>
T min(T a, T b){
    return a < b ? a : b;
}

//Java不支持

//Go
func Min[T int|float64](a, b T) T {
  if a < b {
    return a
  } else {
    return b
  }
}
2. 泛型函数-显示特化
当泛型函数用来支持一个算法用在多种数据类型上，但在某个类型数据上泛型函数的实现不适合该类型，那么我们可以显示特化该类型的实现算法
/C++独有
template<> string min<string>(string a, string b){
    return a.size() < b.size() ? a : b;
}
3.泛型类
泛型类的目的是创建一个集合类型，里面的各种数据类型可以进行相同的操作，泛型类避免了多个数据类型的重复定义"><meta name=author content><link rel=canonical href=https://kmnemon.github.io/posts/2022-06-28-generic-programming/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://kmnemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kmnemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kmnemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://kmnemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://kmnemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://kmnemon.github.io/posts/2022-06-28-generic-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://kmnemon.github.io/posts/2022-06-28-generic-programming/"><meta property="og:site_name" content="科的随思录"><meta property="og:title" content="泛型编程浅入浅出(C++, Java, Go)"><meta property="og:description" content="今年3月随着Go 1.18版发布，引入了一个重大的语言特性：泛型编程。这个特性在发布前引起了一定的争议。崇尚少即是多的一边认为这个特性不是很必要，应该谨慎引入。另一边则认为这是语言必不可少的特性。最后Go的泛型还是如期而至
泛型编程在其他编程语言也遇到了不同的问题，比如在Java 1.0时是没有引入泛型编程支持，到了Java 1.5的时候引入了泛型，但由于引入时间过晚，有大量的标准库和第三方库无法支持，Java选择了妥协采用间接的类型擦除方式来实现泛型编程，导致泛型的使用复杂度增加，同时场景受限。而C++比较明智，一开始就支持泛型，所以在C++ STL标准库里面大量的算法都是采用泛型实现，整个语言体系中泛型占据了核心位置
学习一个语言的特性可以参考其他语言同样的特性，这样就可以了解这个语言特性实现是否设计合理，是否优雅，存在哪些局限性
语言版本：
C++11
Java 11
Go 1.18
1. 泛型函数 泛型函数用来支持当一个算法用在多种数据类型上，为了避免重复的定义函数，而用泛型函数来支持
两个数据进行取小操作
//C++template <class T>T min(T a, T b){return a < b ? a : b;}//Java不支持//Gofunc Min[T int|float64](a, b T) T {if a < b {return a} else {return b}} 2. 泛型函数-显示特化 当泛型函数用来支持一个算法用在多种数据类型上，但在某个类型数据上泛型函数的实现不适合该类型，那么我们可以显示特化该类型的实现算法
/C++独有template<> string min<string>(string a, string b){return a.size() < b.size() ? a : b;} 3.泛型类 泛型类的目的是创建一个集合类型，里面的各种数据类型可以进行相同的操作，泛型类避免了多个数据类型的重复定义"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-03T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-03T00:00:00+00:00"><meta property="og:image" content="https://kmnemon.github.io/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kmnemon.github.io/papermod-cover.png"><meta name=twitter:title content="泛型编程浅入浅出(C++, Java, Go)"><meta name=twitter:description content="今年3月随着Go 1.18版发布，引入了一个重大的语言特性：泛型编程。这个特性在发布前引起了一定的争议。崇尚少即是多的一边认为这个特性不是很必要，应该谨慎引入。另一边则认为这是语言必不可少的特性。最后Go的泛型还是如期而至
泛型编程在其他编程语言也遇到了不同的问题，比如在Java 1.0时是没有引入泛型编程支持，到了Java 1.5的时候引入了泛型，但由于引入时间过晚，有大量的标准库和第三方库无法支持，Java选择了妥协采用间接的类型擦除方式来实现泛型编程，导致泛型的使用复杂度增加，同时场景受限。而C++比较明智，一开始就支持泛型，所以在C++ STL标准库里面大量的算法都是采用泛型实现，整个语言体系中泛型占据了核心位置
学习一个语言的特性可以参考其他语言同样的特性，这样就可以了解这个语言特性实现是否设计合理，是否优雅，存在哪些局限性
语言版本：
C++11
Java 11
Go 1.18
1. 泛型函数
泛型函数用来支持当一个算法用在多种数据类型上，为了避免重复的定义函数，而用泛型函数来支持
两个数据进行取小操作
//C++
template <class T>
T min(T a, T b){
    return a < b ? a : b;
}

//Java不支持

//Go
func Min[T int|float64](a, b T) T {
  if a < b {
    return a
  } else {
    return b
  }
}
2. 泛型函数-显示特化
当泛型函数用来支持一个算法用在多种数据类型上，但在某个类型数据上泛型函数的实现不适合该类型，那么我们可以显示特化该类型的实现算法
/C++独有
template<> string min<string>(string a, string b){
    return a.size() < b.size() ? a : b;
}
3.泛型类
泛型类的目的是创建一个集合类型，里面的各种数据类型可以进行相同的操作，泛型类避免了多个数据类型的重复定义"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kmnemon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"泛型编程浅入浅出(C++, Java, Go)","item":"https://kmnemon.github.io/posts/2022-06-28-generic-programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"泛型编程浅入浅出(C++, Java, Go)","name":"泛型编程浅入浅出(C\u002b\u002b, Java, Go)","description":"今年3月随着Go 1.18版发布，引入了一个重大的语言特性：泛型编程。这个特性在发布前引起了一定的争议。崇尚少即是多的一边认为这个特性不是很必要，应该谨慎引入。另一边则认为这是语言必不可少的特性。最后Go的泛型还是如期而至\n泛型编程在其他编程语言也遇到了不同的问题，比如在Java 1.0时是没有引入泛型编程支持，到了Java 1.5的时候引入了泛型，但由于引入时间过晚，有大量的标准库和第三方库无法支持，Java选择了妥协采用间接的类型擦除方式来实现泛型编程，导致泛型的使用复杂度增加，同时场景受限。而C++比较明智，一开始就支持泛型，所以在C++ STL标准库里面大量的算法都是采用泛型实现，整个语言体系中泛型占据了核心位置\n学习一个语言的特性可以参考其他语言同样的特性，这样就可以了解这个语言特性实现是否设计合理，是否优雅，存在哪些局限性\n语言版本：\nC++11\nJava 11\nGo 1.18\n1. 泛型函数 泛型函数用来支持当一个算法用在多种数据类型上，为了避免重复的定义函数，而用泛型函数来支持\n两个数据进行取小操作\n//C++\rtemplate \u0026lt;class T\u0026gt;\rT min(T a, T b){\rreturn a \u0026lt; b ? a : b;\r}\r//Java不支持\r//Go\rfunc Min[T int|float64](a, b T) T {\rif a \u0026lt; b {\rreturn a\r} else {\rreturn b\r}\r} 2. 泛型函数-显示特化 当泛型函数用来支持一个算法用在多种数据类型上，但在某个类型数据上泛型函数的实现不适合该类型，那么我们可以显示特化该类型的实现算法\n/C++独有\rtemplate\u0026lt;\u0026gt; string min\u0026lt;string\u0026gt;(string a, string b){\rreturn a.size() \u0026lt; b.size() ? a : b;\r} 3.泛型类 泛型类的目的是创建一个集合类型，里面的各种数据类型可以进行相同的操作，泛型类避免了多个数据类型的重复定义\n","keywords":[],"articleBody":"今年3月随着Go 1.18版发布，引入了一个重大的语言特性：泛型编程。这个特性在发布前引起了一定的争议。崇尚少即是多的一边认为这个特性不是很必要，应该谨慎引入。另一边则认为这是语言必不可少的特性。最后Go的泛型还是如期而至\n泛型编程在其他编程语言也遇到了不同的问题，比如在Java 1.0时是没有引入泛型编程支持，到了Java 1.5的时候引入了泛型，但由于引入时间过晚，有大量的标准库和第三方库无法支持，Java选择了妥协采用间接的类型擦除方式来实现泛型编程，导致泛型的使用复杂度增加，同时场景受限。而C++比较明智，一开始就支持泛型，所以在C++ STL标准库里面大量的算法都是采用泛型实现，整个语言体系中泛型占据了核心位置\n学习一个语言的特性可以参考其他语言同样的特性，这样就可以了解这个语言特性实现是否设计合理，是否优雅，存在哪些局限性\n语言版本：\nC++11\nJava 11\nGo 1.18\n1. 泛型函数 泛型函数用来支持当一个算法用在多种数据类型上，为了避免重复的定义函数，而用泛型函数来支持\n两个数据进行取小操作\n//C++\rtemplate T min(T a, T b){\rreturn a \u003c b ? a : b;\r}\r//Java不支持\r//Go\rfunc Min[T int|float64](a, b T) T {\rif a \u003c b {\rreturn a\r} else {\rreturn b\r}\r} 2. 泛型函数-显示特化 当泛型函数用来支持一个算法用在多种数据类型上，但在某个类型数据上泛型函数的实现不适合该类型，那么我们可以显示特化该类型的实现算法\n/C++独有\rtemplate\u003c\u003e string min(string a, string b){\rreturn a.size() \u003c b.size() ? a : b;\r} 3.泛型类 泛型类的目的是创建一个集合类型，里面的各种数据类型可以进行相同的操作，泛型类避免了多个数据类型的重复定义\n//C++\rtemplate\rclass Queue{\rpublic:\rQueue();\r~Queue();\rT\u0026 remove();\rvoid add( const T\u0026);\rbool isEmpty();\r}\r//Java\rpublic class Queue {\rpublic Queue(){\r}\rpublic T remove(){\r//...\r}\rpublic void add(final T a){\r//...\r}\r}\r//Go\rtype Queue[T interface{}] struct{\relement []T\r}\rfunc (q *Queue[T]) remove() *T{\r//...\rfunc (q *Queue[T]) add(a *T){\r//...\r} 类型擦除 前面说到Java是在1.5版本时才引入泛型支持，这个时候已经有大量的工程，类库基于非泛型代码，这个时候引入泛型就会相当复杂，因为不能导致历史代码不兼容。\n这时Java做出了妥协，采用类型擦除的方式实现了泛型，并保持历史代码的兼容性。采用这种方式有一个明显的缺陷是在泛型代码内部，无法获取有关任何泛型参数的信息\n当在代码尝试调用泛型特有的信息时，Java的实现就会变得复杂\n//C++\rtemplate class Manipulator {\rT obj;\rpublic:\rManipulator(T x) { obj = x; }\rvoid manipulate() { obj.f(); }//compiler check\r};\rclass HasF {\rpublic:\rvoid f() { cout \u003c\u003c \"HasF::f()\" \u003c\u003c endl; }\r}; 上面代码调用泛型T的f()方法，在C++的实现中编译器会检查泛型T是否含有f()方法，如果有则编译通过。\n在Java中由于类型被擦除，在编译时刻，编译器无法检查是否含有f()方法，这个调用会编译报错。\nclass Manipulator {\rprivate T obj;\rManipulator(T x) {\robj = x;\r}\r// Error: cannot find symbol: method f():\rpublic void manipulate() {\robj.f();\r}\r} 为了解决这个问题Java在泛型支持中引入新关键字extends，表示该泛型T是后续类型或其子类\npublic class Manipulator2 {\rprivate T obj;\rManipulator2(T x) {\robj = x;\r}\rpublic void manipulate() {\robj.f();\r}\r} 这样引入复杂度才解决这个问题。\n为了缓解类型擦除带来的问题，Java同时还引入通配符?, 逆变super等关键字支持泛型，可见开始语言特性设计考虑不慎，后续就会引入大量不必要的复杂性\n在Go的泛型实现中，就算指定了类型限制，编译器也无法检查调用类型，这方面Go的泛型限制更大，下面代码编译不过\ntype Manipulator[T HasF] struct{\robj T\r}\rfunc (m Manipulator[T]) manipulate(){\rm.obj.f() //compile error: undefined\r}\rtype HasF struct{\r}\rfunc (h HasF) f(){\r} 泛型类特化与偏特化 C++同时还支持泛型类的特化与偏特化能力，这些都是Java与Go泛型不支持的特性，这里就不举例了\n4.泛型方法 当类中少数方法需要泛化，并不需要全面泛化类时，泛型方法就登场了\n//C++\rclass Queue{\rpublic:\rtemplate\rvoid assign(Iter first, Iter last){\r//...\r}\r}\r//Java\rpublic class Queue {\rpublic void assign(Iter first, Iter last){\r//...\r}\r}\r//Go不支持泛型方法 5.泛型接口 当设计接口支持多种数据类型时，就会用到泛型接口\n//C++\rtemplate class\rclass MinMax{\rpublic:\rvirtual T max()=0；\r};\r//Java\rinterface MinMax","wordCount":"339","inLanguage":"zh-cn","image":"https://kmnemon.github.io/papermod-cover.png","datePublished":"2022-07-03T00:00:00Z","dateModified":"2022-07-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kmnemon.github.io/posts/2022-06-28-generic-programming/"},"publisher":{"@type":"Organization","name":"科的随思录","logo":{"@type":"ImageObject","url":"https://kmnemon.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kmnemon.github.io/ accesskey=h title="科的随思录 (Alt + H)">科的随思录</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kmnemon.github.io/archives title=文章><span>文章</span></a></li><li><a href=https://kmnemon.github.io/about title=咖啡><span>咖啡</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kmnemon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://kmnemon.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">泛型编程浅入浅出(C++, Java, Go)</h1><div class=post-meta><span title='2022-07-03 00:00:00 +0000 UTC'>July 3, 2022</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e6%b3%9b%e5%9e%8b%e5%87%bd%e6%95%b0 aria-label="1. 泛型函数">1. 泛型函数</a></li><li><a href=#2-%e6%b3%9b%e5%9e%8b%e5%87%bd%e6%95%b0-%e6%98%be%e7%a4%ba%e7%89%b9%e5%8c%96 aria-label="2. 泛型函数-显示特化">2. 泛型函数-显示特化</a></li><li><a href=#3%e6%b3%9b%e5%9e%8b%e7%b1%bb aria-label=3.泛型类>3.泛型类</a></li><li><a href=#%e7%b1%bb%e5%9e%8b%e6%93%a6%e9%99%a4 aria-label=类型擦除>类型擦除</a></li><li><a href=#%e6%b3%9b%e5%9e%8b%e7%b1%bb%e7%89%b9%e5%8c%96%e4%b8%8e%e5%81%8f%e7%89%b9%e5%8c%96 aria-label=泛型类特化与偏特化>泛型类特化与偏特化</a></li><li><a href=#4%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95 aria-label=4.泛型方法>4.泛型方法</a></li><li><a href=#5%e6%b3%9b%e5%9e%8b%e6%8e%a5%e5%8f%a3 aria-label=5.泛型接口>5.泛型接口</a></li></ul></div></details></div><div class=post-content><p>今年3月随着Go 1.18版发布，引入了一个重大的语言特性：泛型编程。这个特性在发布前引起了一定的争议。崇尚少即是多的一边认为这个特性不是很必要，应该谨慎引入。另一边则认为这是语言必不可少的特性。最后Go的泛型还是如期而至</p><p>泛型编程在其他编程语言也遇到了不同的问题，比如在Java 1.0时是没有引入泛型编程支持，到了Java 1.5的时候引入了泛型，但由于引入时间过晚，有大量的标准库和第三方库无法支持，Java选择了妥协采用间接的类型擦除方式来实现泛型编程，导致泛型的使用复杂度增加，同时场景受限。而C++比较明智，一开始就支持泛型，所以在C++ STL标准库里面大量的算法都是采用泛型实现，整个语言体系中泛型占据了核心位置</p><p>学习一个语言的特性可以参考其他语言同样的特性，这样就可以了解这个语言特性实现是否设计合理，是否优雅，存在哪些局限性</p><p>语言版本：<br>C++11<br>Java 11<br>Go 1.18</p><h3 id=1-泛型函数>1. 泛型函数<a hidden class=anchor aria-hidden=true href=#1-泛型函数>#</a></h3><p>泛型函数用来支持当一个算法用在多种数据类型上，为了避免重复的定义函数，而用泛型函数来支持</p><p>两个数据进行取小操作</p><pre tabindex=0><code>//C++
template &lt;class T&gt;
T min(T a, T b){
    return a &lt; b ? a : b;
}

//Java不支持

//Go
func Min[T int|float64](a, b T) T {
  if a &lt; b {
    return a
  } else {
    return b
  }
}
</code></pre><h3 id=2-泛型函数-显示特化>2. 泛型函数-显示特化<a hidden class=anchor aria-hidden=true href=#2-泛型函数-显示特化>#</a></h3><p>当泛型函数用来支持一个算法用在多种数据类型上，但在某个类型数据上泛型函数的实现不适合该类型，那么我们可以显示特化该类型的实现算法</p><pre tabindex=0><code>/C++独有
template&lt;&gt; string min&lt;string&gt;(string a, string b){
    return a.size() &lt; b.size() ? a : b;
}
</code></pre><h3 id=3泛型类>3.泛型类<a hidden class=anchor aria-hidden=true href=#3泛型类>#</a></h3><p>泛型类的目的是创建一个集合类型，里面的各种数据类型可以进行相同的操作，泛型类避免了多个数据类型的重复定义</p><pre tabindex=0><code>//C++
template&lt;class T&gt;
class Queue{
public:
  Queue();
  ~Queue();
  T&amp; remove();
  void add( const T&amp;);
  bool isEmpty();
}

//Java
public class Queue&lt;T&gt; {
    public Queue(){
    }
    public T remove(){
        //...
    }
    public void add(final T a){
        //...
    }
}

//Go
type Queue[T interface{}] struct{
    element []T
}
func (q *Queue[T]) remove() *T{
    //...
func (q *Queue[T]) add(a *T){
    //...
}
</code></pre><h3 id=类型擦除>类型擦除<a hidden class=anchor aria-hidden=true href=#类型擦除>#</a></h3><p>前面说到Java是在1.5版本时才引入泛型支持，这个时候已经有大量的工程，类库基于非泛型代码，这个时候引入泛型就会相当复杂，因为不能导致历史代码不兼容。</p><p>这时Java做出了妥协，采用类型擦除的方式实现了泛型，并保持历史代码的兼容性。采用这种方式有一个明显的缺陷是在泛型代码内部，无法获取有关任何泛型参数的信息</p><p>当在代码尝试调用泛型特有的信息时，Java的实现就会变得复杂</p><pre tabindex=0><code>//C++
template&lt;class T&gt; 
class Manipulator {
    T obj;
public:
    Manipulator(T x) { obj = x; }
    void manipulate() { obj.f(); }//compiler check
};

class HasF {
public:
    void f() { cout &lt;&lt; &#34;HasF::f()&#34; &lt;&lt; endl; }
};
</code></pre><p>上面代码调用泛型T的f()方法，在C++的实现中编译器会检查泛型T是否含有f()方法，如果有则编译通过。</p><p>在Java中由于类型被擦除，在编译时刻，编译器无法检查是否含有f()方法，这个调用会编译报错。</p><pre tabindex=0><code>
class Manipulator&lt;T&gt; {
    private T obj;
    
    Manipulator(T x) {
        obj = x;
    }
    
    // Error: cannot find symbol: method f():
    public void manipulate() {
        obj.f();
    }
}
</code></pre><p>为了解决这个问题Java在泛型支持中引入新关键字extends，表示该泛型T是后续类型或其子类</p><pre tabindex=0><code>public class Manipulator2&lt;T extends HasF&gt; {
    private T obj;

    Manipulator2(T x) {
        obj = x;
    }

    public void manipulate() {
        obj.f();
    }
}
</code></pre><p>这样引入复杂度才解决这个问题。</p><p>为了缓解类型擦除带来的问题，Java同时还引入通配符?, 逆变super等关键字支持泛型，可见开始语言特性设计考虑不慎，后续就会引入大量不必要的复杂性</p><p>在Go的泛型实现中，就算指定了类型限制，编译器也无法检查调用类型，这方面Go的泛型限制更大，下面代码编译不过</p><pre tabindex=0><code>type Manipulator[T HasF] struct{
    obj T
}
func (m Manipulator[T]) manipulate(){
    m.obj.f() //compile error: undefined
}
type HasF struct{
}
func (h HasF) f(){
}
</code></pre><h3 id=泛型类特化与偏特化>泛型类特化与偏特化<a hidden class=anchor aria-hidden=true href=#泛型类特化与偏特化>#</a></h3><p>C++同时还支持泛型类的特化与偏特化能力，这些都是Java与Go泛型不支持的特性，这里就不举例了</p><h3 id=4泛型方法>4.泛型方法<a hidden class=anchor aria-hidden=true href=#4泛型方法>#</a></h3><p>当类中少数方法需要泛化，并不需要全面泛化类时，泛型方法就登场了</p><pre tabindex=0><code>//C++
class Queue{
public:
   template&lt;class Iter&gt;
      void assign(Iter first, Iter last){
      //...
      }
}

//Java
public class Queue {
   public &lt;Iter&gt; void assign(Iter first, Iter last){
       //...
   }
}

//Go不支持泛型方法
</code></pre><h3 id=5泛型接口>5.泛型接口<a hidden class=anchor aria-hidden=true href=#5泛型接口>#</a></h3><p>当设计接口支持多种数据类型时，就会用到泛型接口</p><pre tabindex=0><code>//C++
template class&lt;T&gt;
class MinMax{
public:
  virtual T max()=0；
};

//Java
interface MinMax&lt;T extends Comparable&lt;T&gt;&gt; {
  T max();
}
class MyClass&lt;T extends Comparable&lt;T&gt;&gt; implements MinMax&lt;T&gt; {
  public T max() {
    //...
  }
}

//Go
type MinMax[T any] interface{
  max() T
}
</code></pre><p>这篇文章介绍了主要的泛型场景，我们看到三种语言泛型能力C++>Java>Go，C++从语言开始设计就考虑泛型没有历史包袱，所以泛型能力最强，表达力最优秀。Java借鉴了C++语言，但在泛型设计上慢了一步后期加入泛型只有采用妥协方式（类型擦除）来实现，在泛型支持场景上受限，同时复杂度增加。Go语言受到原作者的影响，一开始并不想支持泛型，在后期社区反馈中才考虑加入泛型，也作出妥协，增加了复杂度，场景也受限更多。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://kmnemon.github.io/posts/2022-08-14-agile-essence/><span class=title>«</span><br><span>敏捷本质</span>
</a><a class=next href=https://kmnemon.github.io/posts/2022-03-23-intermittent-fasting/><span class=title>»</span><br><span>断食·轻断食</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kmnemon.github.io/>科的随思录</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>