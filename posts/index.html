<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 科的随思录</title>
<meta name=keywords content><meta name=description content="Posts - 科的随思录"><meta name=author content><link rel=canonical href=https://kmnemon.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://kmnemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kmnemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kmnemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://kmnemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://kmnemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kmnemon.github.io/posts/index.xml><link rel=alternate hreflang=zh-cn href=https://kmnemon.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://kmnemon.github.io/posts/"><meta property="og:site_name" content="科的随思录"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta property="og:image" content="https://kmnemon.github.io/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kmnemon.github.io/papermod-cover.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kmnemon.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kmnemon.github.io/ accesskey=h title="科的随思录 (Alt + H)">科的随思录</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kmnemon.github.io/archives title=文章><span>文章</span></a></li><li><a href=https://kmnemon.github.io/about title=咖啡><span>咖啡</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://kmnemon.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>敏捷日记 - 1.回到起点</h2></header><div class=entry-content><p>在软件行业摸爬滚很多年，从开发软件采用分布式编译技术也需要一天一夜才能编译完成一套系统，大家都在使用16寸CRT编写代码的时代，到现在一台Mac的性能远超当时的集群性能。当年一本《硝烟中的Scrum和XP》读的津津乐道，学到的新东西立马在团队试用，到后来作为敏捷教练帮助企业组织转型。近几年企业开始“降本增效”风潮，普遍看到的只是“降本”，采用精益敏捷的方式减少浪费提升效率的实在太少。有时候看到明明只需1/2甚至1/3的人，改变做事方式，就能比现在更好，但企业还是倾向于低效堆人，十分感叹。
言归正传，很早作为软件工程师的时候，喜欢在工作外写一些小工具帮助团队自动化一些事情，这个习惯在做教练的时候也继续保持着，估计还是内心喜欢写代码这件很纯粹有趣的事情。以前也想过开发一些面向用户的软件，投向市场，看看能不能掀起一点浪花。也跟曾经的团队聊过，无奈大家都要吃饭，养家，靠爱发电似乎难以实现。大家都知道现在这类软件基本很难有市场，所以这件事情一直搁置着，但内心仍有不甘。
在从事敏捷教练期间听到最多的争论是“敏捷教练不要只当裁判，也要下场踢球”，“既要管杀，也要管埋”。于是教练不仅要传递知识，方法论，也要下场带着团队一起干。虽然这样，但进行软件交付的核心工作还是团队。除了通过帮助团队，自己也想深度体验敏捷，迭代，持续交付能做到什么程度，所以内心有个想法，自己分别扮演PO，Team，Scrum Master，从一个想法开始，到实现一个软件并推向市场。在这个过程中会对产品经理，开发，测试，运维，运营等角色在敏捷活动中怎样高效的协作有更深入的理解。记录这个过程中发生的事情，分享给大家，希望能有一些帮助。
可以预见执行过程中的难点，一个是能不能完全实现这些想法，中间肯定会遇到各种困难需要去解决，第二个是主要是时间投入的保证，最近公司开始重视提效，希望能有所帮助，估计会有些忙，家里还有小朋友需要陪伴，考验怎样合理安排时间。好了暂时想到这些。
初步想法如下：
迭代周期为一周，在迭代内既要完成当前迭代的开发，也要完成下迭代用户故事的准备 采用用户故事地图进行版本规划 采用看板进行每日任务跟踪 每周进行回顾 借用TDD思维进行开发，但不完全遵循TDD的步骤 那么下周开始&lt;迭代0-迭代准备阶段>：
准备完成商业模式画布，用户建模，用户故事地图，迭代1用户故事准备,准备决策看板，任务看板
Week 1: Sprint 0 - 迭代准备</p></div><footer class=entry-footer><span title='2025-02-09 00:00:00 +0000 UTC'>February 9, 2025</span></footer><a class=entry-link aria-label="post link to 敏捷日记 - 1.回到起点" href=https://kmnemon.github.io/posts/2025-02-09-start-agile/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>现代语言怎么支持Parallel和Concurrent</h2></header><div class=entry-content><p>Parallel和Concurrent 我们先来回顾一下概念: Parallel是指同时执行多个任务或计算.通常在多核或多处理器的硬件上并行执行多个操作,每个操作独立运行,并且是同步的(并行的任务在同一时刻发生).并行计算的目标是通过同时使用多个计算资源来加速程序的执行.
Concurrent是指系统在同一时间段内处理多个任务的能力.并发并不意味着任务是同时执行的,而是任务在某一时刻轮流执行.
举个例子就更容易理解： 你有一个奶茶店,制作奶茶需要三个步骤,分别是收银,调制奶茶配料和用设备制作奶茶.假设现在有两个角色,A负责收银,B负责调制奶茶配料和用设备制作奶茶.整个步骤是A->B.作为店主你很快发现A收银很快,B调制配料和制作奶茶很慢造成了瓶颈,这是你选择解决方案是再雇佣了另外一个人和B一起负责调制奶茶配料和用设备制作奶茶,现在整个步骤是A->B1 or B2.在这个场景中增加B2就是我们说的Parallel.当然你还可以用另一个方案解决,把原步骤调制奶茶配料和用设备制作奶茶拆分为两个步骤,分别让B负责调制奶茶配料,再雇佣一个人去负责用设备制作奶茶,步骤变为A->B->C,在这个场景中增加C就是增加了Concurrent.
现代语言的并发模型 现代语言支持并发模型一般会在操作系统线程和应用程序之间增加一层,在这层中使用预先分配的线程池和调度器来实现应用程序的并发能力.如在Go语言中称为协程(Coroutine). Go语言的并发模型如下: G—Goroutine M—OS thread (stands for machine) P—CPU core (stands for processor) 默认情况每一个CPU核心(P)里面会有一个线程(M),每个线程会不断切换去运行协程(G).
Swift语言的并发模型,同样也是在操作系统线程和应用程序之间增加了一层.稍有不同的是他通过把代码划分为逻辑单元称为局部任务(Partial Tasks),通过调度器把局部任务分配到线程池不同的线程运行来实现并发能力. 现代语言中支持并发的语言特性 那么在这些语言中怎么支持并发的呢？这里我们举例三个场景:
场景1: 增加Parallel,就是我们前面说的第一个方案增加另一个人和B一起负责调制奶茶配料和用设备制作奶茶 Go实现
func taskA() int {
time.Sleep(2 * time.Second)
return 5
}
func parallelExample() int {
c := make(chan int)
go func() {
c &lt;- taskA()
}()
go func() {
c &lt;- taskA()
}()
r1 := &lt;-c
r2 := &lt;-c
return r1 + r2
} Swift实现
...</p></div><footer class=entry-footer><span title='2025-01-02 00:00:00 +0000 UTC'>January 2, 2025</span></footer><a class=entry-link aria-label="post link to 现代语言怎么支持Parallel和Concurrent" href=https://kmnemon.github.io/posts/2025-01-02-parallel-concurrent/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SwiftUI @State、@Observable、@Binding、@Bindable实现原理</h2></header><div class=entry-content><p>@State 用途 struct 1.私有的View State，使用当前View维护状态生命周期 2.保持struct不可变性的同时修改内部变量值
class 1.私有的View State，使用当前View维护状态生命周期
使用方式 struct Counter: View {
@State private var value = 0
var body: some View {
Button("Increment: \(value)") {
value += 1
}
}
} 内部实现 struct Counter: View {
private var _value = State(initialValue: 0)
private var value: Int {
get { _value.wrappedValue }
nonmutating set { _value.wrappedValue = newValue }
}
var body: some View {
Button("Increment: \(value)") {
value += 1
}
}
} SwiftUI给value state在render tree里面分配内存并赋予initialValue:0，并建立链接使value指向这个内存值 Counter’s body依赖这个内存值，一旦内存值变化会重新构建Counter’s body.
...</p></div><footer class=entry-footer><span title='2024-11-29 00:00:00 +0000 UTC'>November 29, 2024</span></footer><a class=entry-link aria-label="post link to SwiftUI @State、@Observable、@Binding、@Bindable实现原理" href=https://kmnemon.github.io/posts/2024-11-29-state-binding-bindable/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>编译器是否帮我们做的过多？</h2></header><div class=entry-content><p>近段时间编程语言开始往安全方面进行发展，类型安全，内存安全，并发安全等，如新兴的Rust语言，Swift 6.0都在安全性上发力，并都在编译器方面下功夫，添加了诸多规则，当你和编译器战斗通过后，理论上你的代码具备某种程度的安全性。
这类安全性同时也影响着语言的发展，比如在面向接口编程中Swift语言里面对于接口还增加了some和any两个关键字，一时让我疑惑不解，其他语言没有这类概念为啥这个语言需要，他想要解决了什么问题？然后又引入两个类型概念Opaque Types和Boxed Protocol Types。
官方文档描述如下：
“You can think of an opaque type like being the reverse of a generic type. … An opaque type lets the function implementation pick the type for the value it returns in a way that’s abstracted away from the code that calls the function. … An opaque type refers to one specific type, although the caller of the function isn’t able to see which type”
...</p></div><footer class=entry-footer><span title='2024-11-19 00:00:00 +0000 UTC'>November 19, 2024</span></footer><a class=entry-link aria-label="post link to 编译器是否帮我们做的过多？" href=https://kmnemon.github.io/posts/2024-11-19-does-compilor-do-to-much/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>程序语言中内存管理-DO NOT STOP THE WORLD</h2></header><div class=entry-content><p>类似枪械有手动步枪-M1903春田，半自动步枪-M1，自动步枪-M16之分，程序语言的内存管理也有手动、半自动和全自动三种方式。手动内存管理的代表语言：C、C++，半自动内存管理的代码语言：Modern C++，Swift，Rust，全自动的代表语言：Java，C#，Go，Python。本文通过不同程序语言来描述三种内存管理方式，以及如何应对循环引用的典型场景。
手动内存管理： 为了实现代码的极致效率以及灵活性C和C++语言采用了手动内存管理方式，通过自己编写代码实现堆上的内存分配与回收。
//C++代码示例
export class Manual {
public:
Manual(int s) :elem{ new double[s] }, sz{ s } {}
~Manual() {
delete[] elem;
}
private:
double* elem;
int sz;
}; 半自动内存管理： 内存泄漏是手动内存管理遇到最大的挑战，在复杂的场景下可能出现分配的内存没有释放，导致程序在特殊的情况下内存耗尽停止工作。为了保证内存安全，新一代语言为了不牺牲效率采用编译时期来分析内存的分配与释放，典型的方式是自动引用计数（Automatic Reference Counting ）
//swift代码示例
class ARC {
}
func usingARC() {
var ref1: ARC? = ARC()
var ref2: ARC? = ref1
ref1 = nil
ref2 = nil
//ref1、ref2 已释放
} //Modern C++
export class SmartPointers {
public:
//represents unique ownership (its destructor destroys its object)
void uniquePtr() {
std::unique_ptr&lt;X> sp{ new X };
std::unique_ptr&lt;X> sp3 = std::make_unique&lt;X>();
std::unique_ptr&lt;X> sp2 = std::move(sp);
}
//represents shared ownership (the last shared pointer¡¯s destructor destroys the object)
void sharedPtr() {
std::shared_ptr&lt;X> sp = std::make_shared&lt;X>();
std::shared_ptr&lt;X> sp2 = sp;
sp.reset();
sp2.reset();
}
//A pointer to an object owned by a shared_ptr
void weakPtr() {
std::shared_ptr&lt;X> sharedPtr = std::make_shared&lt;X>();
// Creating a weak pointer from the shared pointer
std::weak_ptr&lt;X> weakPtr = sharedPtr;
// Using the weak pointer to access the object
if (auto ptr = weakPtr.lock()) {
}
else {
std::cout &lt;&lt; "Weak pointer is expired." &lt;&lt; std::endl;
}
// Resetting the shared pointer
sharedPtr.reset();
// Using the weak pointer again after resetting the shared pointer
if (auto ptr = weakPtr.lock()) {
}
else {
std::cout &lt;&lt; "Weak pointer is expired." &lt;&lt; std::endl;
}
}
}; 全自动内存管理： 同样保证内存安全，同时减少内存管理心智负担，还有一种全自动内存管理-垃圾回收机制（GC）。但这种方式引入了臭名昭著的STOP THE WORLD。
...</p></div><footer class=entry-footer><span title='2024-03-26 00:00:00 +0000 UTC'>March 26, 2024</span></footer><a class=entry-link aria-label="post link to 程序语言中内存管理-DO NOT STOP THE WORLD" href=https://kmnemon.github.io/posts/2024-03-26-do-not-stop-the-world/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://kmnemon.github.io/posts/page/2/>&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://kmnemon.github.io/>科的随思录</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>