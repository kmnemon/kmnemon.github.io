<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SwiftUI @State、@Observable、@Binding、@Bindable实现原理 | 科的随思录</title>
<meta name=keywords content><meta name=description content='@State
用途
struct
1.私有的View State，使用当前View维护状态生命周期
2.保持struct不可变性的同时修改内部变量值
class
1.私有的View State，使用当前View维护状态生命周期
使用方式
struct Counter: View {
    @State private var value = 0

    var body: some View {
        Button("Increment: \(value)") {
            value += 1
        }
    }
}
内部实现
struct Counter: View {
    private var _value = State(initialValue: 0)
    private var value: Int {
        get { _value.wrappedValue }
        nonmutating set { _value.wrappedValue = newValue }
    }

    var body: some View {
        Button("Increment: \(value)") {
            value += 1
        }
    }
}
SwiftUI给value state在render tree里面分配内存并赋予initialValue:0，并建立链接使value指向这个内存值
Counter&rsquo;s body依赖这个内存值，一旦内存值变化会重新构建Counter&rsquo;s body.'><meta name=author content><link rel=canonical href=https://kmnemon.github.io/posts/2024-11-29-state-binding-bindable/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://kmnemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kmnemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kmnemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://kmnemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://kmnemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://kmnemon.github.io/posts/2024-11-29-state-binding-bindable/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://kmnemon.github.io/posts/2024-11-29-state-binding-bindable/"><meta property="og:site_name" content="科的随思录"><meta property="og:title" content="SwiftUI @State、@Observable、@Binding、@Bindable实现原理"><meta property="og:description" content='@State 用途 struct 1.私有的View State，使用当前View维护状态生命周期 2.保持struct不可变性的同时修改内部变量值
class 1.私有的View State，使用当前View维护状态生命周期
使用方式 struct Counter: View {@State private var value = 0var body: some View {Button("Increment: \(value)") {value += 1}}} 内部实现 struct Counter: View {private var _value = State(initialValue: 0)private var value: Int {get { _value.wrappedValue }nonmutating set { _value.wrappedValue = newValue }}var body: some View {Button("Increment: \(value)") {value += 1}}} SwiftUI给value state在render tree里面分配内存并赋予initialValue:0，并建立链接使value指向这个内存值 Counter’s body依赖这个内存值，一旦内存值变化会重新构建Counter’s body.'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-29T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-29T00:00:00+00:00"><meta property="og:image" content="https://kmnemon.github.io/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kmnemon.github.io/papermod-cover.png"><meta name=twitter:title content="SwiftUI @State、@Observable、@Binding、@Bindable实现原理"><meta name=twitter:description content='@State
用途
struct
1.私有的View State，使用当前View维护状态生命周期
2.保持struct不可变性的同时修改内部变量值
class
1.私有的View State，使用当前View维护状态生命周期
使用方式
struct Counter: View {
    @State private var value = 0

    var body: some View {
        Button("Increment: \(value)") {
            value += 1
        }
    }
}
内部实现
struct Counter: View {
    private var _value = State(initialValue: 0)
    private var value: Int {
        get { _value.wrappedValue }
        nonmutating set { _value.wrappedValue = newValue }
    }

    var body: some View {
        Button("Increment: \(value)") {
            value += 1
        }
    }
}
SwiftUI给value state在render tree里面分配内存并赋予initialValue:0，并建立链接使value指向这个内存值
Counter&rsquo;s body依赖这个内存值，一旦内存值变化会重新构建Counter&rsquo;s body.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kmnemon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SwiftUI @State、@Observable、@Binding、@Bindable实现原理","item":"https://kmnemon.github.io/posts/2024-11-29-state-binding-bindable/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SwiftUI @State、@Observable、@Binding、@Bindable实现原理","name":"SwiftUI @State、@Observable、@Binding、@Bindable实现原理","description":"@State 用途 struct 1.私有的View State，使用当前View维护状态生命周期 2.保持struct不可变性的同时修改内部变量值\nclass 1.私有的View State，使用当前View维护状态生命周期\n使用方式 struct Counter: View {\r@State private var value = 0\rvar body: some View {\rButton(\u0026#34;Increment: \\(value)\u0026#34;) {\rvalue += 1\r}\r}\r} 内部实现 struct Counter: View {\rprivate var _value = State(initialValue: 0)\rprivate var value: Int {\rget { _value.wrappedValue }\rnonmutating set { _value.wrappedValue = newValue }\r}\rvar body: some View {\rButton(\u0026#34;Increment: \\(value)\u0026#34;) {\rvalue += 1\r}\r}\r} SwiftUI给value state在render tree里面分配内存并赋予initialValue:0，并建立链接使value指向这个内存值 Counter\u0026rsquo;s body依赖这个内存值，一旦内存值变化会重新构建Counter\u0026rsquo;s body.\n","keywords":[],"articleBody":"@State 用途 struct 1.私有的View State，使用当前View维护状态生命周期 2.保持struct不可变性的同时修改内部变量值\nclass 1.私有的View State，使用当前View维护状态生命周期\n使用方式 struct Counter: View {\r@State private var value = 0\rvar body: some View {\rButton(\"Increment: \\(value)\") {\rvalue += 1\r}\r}\r} 内部实现 struct Counter: View {\rprivate var _value = State(initialValue: 0)\rprivate var value: Int {\rget { _value.wrappedValue }\rnonmutating set { _value.wrappedValue = newValue }\r}\rvar body: some View {\rButton(\"Increment: \\(value)\") {\rvalue += 1\r}\r}\r} SwiftUI给value state在render tree里面分配内存并赋予initialValue:0，并建立链接使value指向这个内存值 Counter’s body依赖这个内存值，一旦内存值变化会重新构建Counter’s body.\n@Observable 用途 1.给Object增加Observable marker protocol 2.追踪Object’s properties的读和写\n使用方式 1.使用CounterView管理model生命周期\n@Observable final class Model {\rvar value = 0\r}\rstruct Counter: View {\r@State private var model = Model()\rvar body: some View {\rButton(\"Increment: \\(model.value)\") {\rmodel.value += 1\r}\r}\r} 2.外部传递，由外部对象管理生命周期\n@Observable final class Model {\rvar value = 0\rstatic let shared = Model()\r}\rstruct Counter: View {\rvar model: Model\rvar body: some View {\rButton(\"Increment: \\(model.value)\") {\rmodel.value += 1\r}\r}\r}\rstruct ContentView: View {\rvar body: some View {\rCounter(model: Model.shared)\r}\r} 内部实现 @Observable final class Model {\rvar value = 0 {\rget {\raccess(keyPath: \\.value )\rreturn _value\r}\rset {\rwithMutation(keyPath: \\.value ) {\r_value = newValue\r}\r}\r}\r@ObservationIgnored private var _value = 0\r//…\r}\r//展开access和withMutatio\r@Observable final class Model {\r//…\r@ObservationIgnored private let _$observationRegistrar = ObservationRegistrar()\rinternal nonisolated func access(keyPath: KeyPath) {\r_$observationRegistrar.access(self, keyPath: keyPath)\r}\rinternal nonisolated func withMutation(\rkeyPath: KeyPath,\r_ mutation: () throws -\u003e T\r) rethrows -\u003e T {\rtry _$observationRegistrar.withMutation(of: self, keyPath: keyPath, mutation)\r}\r} access和withMutation两个方法会被observationRegistrar调用. registrar负责保持observers订阅的properties，并通知observers这些properties的变化. SwiftUI有个withObservationTracking(_ apply:onChange:)全局函数. 其中apply闭包会立即执行，帮助observation订阅对象. onChange闭包是observer，当observable properties变化时被调用.\napply调用后，object的accessd properties和observer闭包，建立关联性.\n类似如下：\nwithObservationTracking {\rview.body\r} onChange: {\rview.needsUpdate()\r} 上述代码表示任何view.body内的observable property都通过object’s observation registrar注册.并将property和当前view.body形成关联关系.\n@Binding 用途 1.确保app的状态一致性，每个状态都有一个单一源(source of truth) 2.property从外面传递进来\n使用方式 struct Counter: View {\r@Binding var value: Int\rvar body: some View {\rButton(\"Increment: \\(value)\") { value += 1 }\r}\r}\rstruct ContentView: View {\r@State private var value = 0\rvar body: some View {\rCounter(value: $value)\r}\r} 内部实现 //1.简单实现\rstruct Counter: View {\rvar value: Int\rvar setValue: (Int) -\u003e ()\rvar body: some View {\rButton(\"Increment: \\(value)\") { setValue(value + 1) }\r}\r}\rstruct ContentView: View {\r@State private var value = 0\rvar body: some View {\rCounter(value: value, setValue: { value = $0 })\r}\r}\r//2.使用Binding类型\rstruct Counter: View {\rvar value: Binding\rvar body: some View {\rButton(\"Increment: \\(value.wrappedValue)\") {\rvalue.wrappedValue += 1\r}\r}\r}\r//使用computed value 简化使用，避免直接调用wrappedValue\rstruct Counter: View {\rvar _value: Binding\rvar value: Int {\rget { _value.wrappedValue }\rset { _value.wrappedValue = newValue }\r}\rinit(value: Binding) {\rself._value = value\r}\rvar body: some View {\rButton(\"Increment: \\(value)\") { value += 1 }\r}\r}\rstruct ContentView: View {\r@State private var value = 0\rvar body: some View {\rCounter(value: Binding(get: { value }, set: { value = $0 }))\r}\r} 在ContentView里面set:把 $0和@State private property value关联起来，当Counter里面使用$0改变value值，会导致Counter view被重新构建 前面使用$value,是取用@State property的projectedValue($是取用property wrapper’s projectedValue的语法糖), 该projectedValue实现Binding(get: { value }, set: { value = $0 }),实现如下:\nstruct ContentView: View {\rprivate var _value = State(initialValue: 0)\rprivate var value: Int {\rget { _value.wrappedValue }\rset { _value.wrappedValue = newValue }\r}\rvar body: some View {\rCounter(value: _value.projectedValue)\r}\r} @Bindable 用途 1.解决Observable Object没有使用@State warpper,因此没有projectedValue,无法使用$value进行唯一源绑定,如下示例使用Bindable可以直接传递model对象进Counter 2.@Binable 构建了projectedValue, 如下例可以在Counter里面使用$语法糖进行object property的绑定\n使用方式 1.使用property wrapper\n@Observable final class Model {\rvar value = 0\rstatic let shared = Model()\r}\rstruct Counter: View {\r@Bindable var model: Model\rvar body: some View {\rStepper(\"\\(model.value)\", value: $model.value)\r}\r}\rstruct ContentView: View {\rvar model = Model.shared\rvar body: some View {\rCounter(model: model)\r}\r} 2.使用inline方式\nstruct ContentView: View {\rvar model = Model.shared\rvar body: some View {\rStepper(\"\\(model.value)\", value: Bindable(model).value)\r}\r} 不使用Counter View,直接使用Bindable(model).value建立联接\n内部实现 struct Counter: View {\rvar _model: Bindable\rvar model: Model { _model.wrappedValue }\rinit(model: Model) {\r_model = Bindable(wrappedValue: model)\r}\rvar body: some View {\rStepper(\"\\(model.value)\", value: _model.projectedValue[dynamicMember: \\.value])\r}\r} 使用动态成员查找语法projectedValue[dynamicMember: .value],查找需要修改的object property\n怎么选择 优先选择不使用任何property wrapper,如果我们只是传递值给view, view并不需要改变这个值 关于value,如果view需要改变这个值,view自己管理对象使用@State,由外部传入使用@Binding 关于object,view自己管理对象使用@State, @Observable, 如果由外部传入使用@Observable 关于object由外部传入使用@Observable, 还想进行后续使用$进行关联,还需使用@Bindable ","wordCount":"670","inLanguage":"zh-cn","image":"https://kmnemon.github.io/papermod-cover.png","datePublished":"2024-11-29T00:00:00Z","dateModified":"2024-11-29T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kmnemon.github.io/posts/2024-11-29-state-binding-bindable/"},"publisher":{"@type":"Organization","name":"科的随思录","logo":{"@type":"ImageObject","url":"https://kmnemon.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kmnemon.github.io/ accesskey=h title="科的随思录 (Alt + H)">科的随思录</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kmnemon.github.io/archives title=文章><span>文章</span></a></li><li><a href=https://kmnemon.github.io/about title=咖啡><span>咖啡</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kmnemon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://kmnemon.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">SwiftUI @State、@Observable、@Binding、@Bindable实现原理</h1><div class=post-meta><span title='2024-11-29 00:00:00 +0000 UTC'>November 29, 2024</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#state aria-label=@State>@State</a><ul><ul><li><a href=#%e7%94%a8%e9%80%94 aria-label=用途>用途</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f aria-label=使用方式>使用方式</a></li><li><a href=#%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0 aria-label=内部实现>内部实现</a></li></ul></ul></li><li><a href=#observable aria-label=@Observable>@Observable</a><ul><ul><li><a href=#%e7%94%a8%e9%80%94-1 aria-label=用途>用途</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f-1 aria-label=使用方式>使用方式</a></li><li><a href=#%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0-1 aria-label=内部实现>内部实现</a></li></ul></ul></li><li><a href=#binding aria-label=@Binding>@Binding</a><ul><ul><li><a href=#%e7%94%a8%e9%80%94-2 aria-label=用途>用途</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f-2 aria-label=使用方式>使用方式</a></li><li><a href=#%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0-2 aria-label=内部实现>内部实现</a></li></ul></ul></li><li><a href=#bindable aria-label=@Bindable>@Bindable</a><ul><ul><li><a href=#%e7%94%a8%e9%80%94-3 aria-label=用途>用途</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f-3 aria-label=使用方式>使用方式</a></li><li><a href=#%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0-3 aria-label=内部实现>内部实现</a></li></ul></ul></li><li><a href=#%e6%80%8e%e4%b9%88%e9%80%89%e6%8b%a9 aria-label=怎么选择>怎么选择</a></li></ul></div></details></div><div class=post-content><h1 id=state>@State<a hidden class=anchor aria-hidden=true href=#state>#</a></h1><h3 id=用途>用途<a hidden class=anchor aria-hidden=true href=#用途>#</a></h3><p>struct
1.私有的View State，使用当前View维护状态生命周期
2.保持struct不可变性的同时修改内部变量值</p><p>class
1.私有的View State，使用当前View维护状态生命周期</p><h3 id=使用方式>使用方式<a hidden class=anchor aria-hidden=true href=#使用方式>#</a></h3><pre tabindex=0><code>struct Counter: View {
    @State private var value = 0

    var body: some View {
        Button(&#34;Increment: \(value)&#34;) {
            value += 1
        }
    }
}
</code></pre><h3 id=内部实现>内部实现<a hidden class=anchor aria-hidden=true href=#内部实现>#</a></h3><pre tabindex=0><code>struct Counter: View {
    private var _value = State(initialValue: 0)
    private var value: Int {
        get { _value.wrappedValue }
        nonmutating set { _value.wrappedValue = newValue }
    }

    var body: some View {
        Button(&#34;Increment: \(value)&#34;) {
            value += 1
        }
    }
}
</code></pre><p>SwiftUI给value state在render tree里面分配内存并赋予initialValue:0，并建立链接使value指向这个内存值
Counter&rsquo;s body依赖这个内存值，一旦内存值变化会重新构建Counter&rsquo;s body.</p><h1 id=observable>@Observable<a hidden class=anchor aria-hidden=true href=#observable>#</a></h1><h3 id=用途-1>用途<a hidden class=anchor aria-hidden=true href=#用途-1>#</a></h3><p>1.给Object增加Observable marker protocol
2.追踪Object&rsquo;s properties的读和写</p><h3 id=使用方式-1>使用方式<a hidden class=anchor aria-hidden=true href=#使用方式-1>#</a></h3><p>1.使用CounterView管理model生命周期</p><pre tabindex=0><code>@Observable final class Model {
    var value = 0
}

struct Counter: View {
    @State private var model = Model()
    var body: some View {
        Button(&#34;Increment: \(model.value)&#34;) {
            model.value += 1
        }
    }
}
</code></pre><p>2.外部传递，由外部对象管理生命周期</p><pre tabindex=0><code>@Observable final class Model {
    var value = 0
    static let shared = Model()
}

struct Counter: View {
    var model: Model
    var body: some View {
        Button(&#34;Increment: \(model.value)&#34;) {
            model.value += 1
        }
    }
}

struct ContentView: View {
    var body: some View {
        Counter(model: Model.shared)
    }
}
</code></pre><h3 id=内部实现-1>内部实现<a hidden class=anchor aria-hidden=true href=#内部实现-1>#</a></h3><pre tabindex=0><code>@Observable final class Model {
    var value = 0 {
        get {
            access(keyPath: \.value )
            return _value
        }
        set {
            withMutation(keyPath: \.value ) {
                _value = newValue
            }
        }
    }
    @ObservationIgnored private var _value = 0
    //…
}

//展开access和withMutatio
@Observable final class Model {
    //…
    @ObservationIgnored private let _$observationRegistrar = ObservationRegistrar()
    internal nonisolated func access&lt;Member&gt;(keyPath: KeyPath&lt;Model , Member&gt;) {
        _$observationRegistrar.access(self, keyPath: keyPath)
    }
    internal nonisolated func withMutation&lt;Member, T&gt;(
        keyPath: KeyPath&lt;Model , Member&gt;,
        _ mutation: () throws -&gt; T
    ) rethrows -&gt; T {
        try _$observationRegistrar.withMutation(of: self, keyPath: keyPath, mutation)
    }
}
</code></pre><p>access和withMutation两个方法会被observationRegistrar调用. registrar负责保持observers订阅的properties，并通知observers这些properties的变化.
SwiftUI有个withObservationTracking(_ apply:onChange:)全局函数. 其中apply闭包会立即执行，帮助observation订阅对象. onChange闭包是observer，当observable properties变化时被调用.</p><p>apply调用后，object的accessd properties和observer闭包，建立关联性.</p><p>类似如下：</p><pre tabindex=0><code>withObservationTracking {
    view.body
} onChange: {
    view.needsUpdate()
}
</code></pre><p>上述代码表示任何view.body内的observable property都通过object&rsquo;s observation registrar注册.并将property和当前view.body形成关联关系.</p><h1 id=binding>@Binding<a hidden class=anchor aria-hidden=true href=#binding>#</a></h1><h3 id=用途-2>用途<a hidden class=anchor aria-hidden=true href=#用途-2>#</a></h3><p>1.确保app的状态一致性，每个状态都有一个单一源(source of truth)
2.property从外面传递进来</p><h3 id=使用方式-2>使用方式<a hidden class=anchor aria-hidden=true href=#使用方式-2>#</a></h3><pre tabindex=0><code>struct Counter: View {
    @Binding var value: Int
    var body: some View {
        Button(&#34;Increment: \(value)&#34;) { value += 1 }
    }
}

struct ContentView: View {
    @State private var value = 0
    var body: some View {
        Counter(value: $value)
    }
}
</code></pre><h3 id=内部实现-2>内部实现<a hidden class=anchor aria-hidden=true href=#内部实现-2>#</a></h3><pre tabindex=0><code>//1.简单实现
struct Counter: View {
    var value: Int
    var setValue: (Int) -&gt; ()
    var body: some View {
        Button(&#34;Increment: \(value)&#34;) { setValue(value + 1) }
    }
}

struct ContentView: View {
    @State private var value = 0
    var body: some View {
        Counter(value: value, setValue: { value = $0 })
    }
}

//2.使用Binding类型
struct Counter: View {
    var value: Binding&lt;Int&gt;
    var body: some View {
        Button(&#34;Increment: \(value.wrappedValue)&#34;) {
            value.wrappedValue += 1
        }
    }
}

//使用computed value 简化使用，避免直接调用wrappedValue
struct Counter: View {
    var _value: Binding&lt;Int&gt;
    var value: Int {
        get { _value.wrappedValue }
        set { _value.wrappedValue = newValue }
    }
    init(value: Binding&lt;Int&gt;) {
        self._value = value
    }
    var body: some View {
        Button(&#34;Increment: \(value)&#34;) { value += 1 }
    }
}

struct ContentView: View {
    @State private var value = 0
    var body: some View {
        Counter(value: Binding(get: { value }, set: { value = $0 }))
    }
}
</code></pre><p>在ContentView里面set:把 $0和@State private property value关联起来，当Counter里面使用$0改变value值，会导致Counter view被重新构建
前面使用$value,是取用@State property的projectedValue($是取用property wrapper&rsquo;s projectedValue的语法糖), 该projectedValue实现Binding(get: { value }, set: { value = $0 }),实现如下:</p><pre tabindex=0><code>struct ContentView: View {
    private var _value = State(initialValue: 0)
    private var value: Int {
        get { _value.wrappedValue }
        set { _value.wrappedValue = newValue }
    }
    var body: some View {
        Counter(value: _value.projectedValue)
    }
}
</code></pre><h1 id=bindable>@Bindable<a hidden class=anchor aria-hidden=true href=#bindable>#</a></h1><h3 id=用途-3>用途<a hidden class=anchor aria-hidden=true href=#用途-3>#</a></h3><p>1.解决Observable Object没有使用@State warpper,因此没有projectedValue,无法使用$value进行唯一源绑定,如下示例使用Bindable可以直接传递model对象进Counter
2.@Binable 构建了projectedValue, 如下例可以在Counter里面使用$语法糖进行object property的绑定</p><h3 id=使用方式-3>使用方式<a hidden class=anchor aria-hidden=true href=#使用方式-3>#</a></h3><p>1.使用property wrapper</p><pre tabindex=0><code>@Observable final class Model {
    var value = 0
    static let shared = Model()
}

struct Counter: View {
    @Bindable var model: Model
    var body: some View {
        Stepper(&#34;\(model.value)&#34;, value: $model.value)
    }
}

struct ContentView: View {
    var model = Model.shared
    var body: some View {
        Counter(model: model)
    }
}
</code></pre><p>2.使用inline方式</p><pre tabindex=0><code>struct ContentView: View {
    var model = Model.shared
    var body: some View {
        Stepper(&#34;\(model.value)&#34;, value: Bindable(model).value)
    }
}
</code></pre><p>不使用Counter View,直接使用Bindable(model).value建立联接</p><h3 id=内部实现-3>内部实现<a hidden class=anchor aria-hidden=true href=#内部实现-3>#</a></h3><pre tabindex=0><code>struct Counter: View {
    var _model: Bindable&lt;Model&gt;
    var model: Model { _model.wrappedValue }
    
    init(model: Model) {
        _model = Bindable(wrappedValue: model)
    }
    var body: some View {
        Stepper(&#34;\(model.value)&#34;, value: _model.projectedValue[dynamicMember: \.value])
    }
}
</code></pre><p>使用动态成员查找语法projectedValue[dynamicMember: .value],查找需要修改的object property</p><h1 id=怎么选择>怎么选择<a hidden class=anchor aria-hidden=true href=#怎么选择>#</a></h1><ol><li>优先选择不使用任何property wrapper,如果我们只是传递值给view, view并不需要改变这个值</li><li>关于value,如果view需要改变这个值,view自己管理对象使用@State,由外部传入使用@Binding</li><li>关于object,view自己管理对象使用@State, @Observable, 如果由外部传入使用@Observable</li><li>关于object由外部传入使用@Observable, 还想进行后续使用$进行关联,还需使用@Bindable</li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://kmnemon.github.io/posts/2025-01-02-parallel-concurrent/><span class=title>«</span><br><span>现代语言怎么支持Parallel和Concurrent</span>
</a><a class=next href=https://kmnemon.github.io/posts/2024-11-19-does-compilor-do-to-much/><span class=title>»</span><br><span>编译器是否帮我们做的过多？</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kmnemon.github.io/>科的随思录</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>